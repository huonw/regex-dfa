var searchIndex = {};
searchIndex['regex_dfa'] = {"items":[[0,"","regex_dfa","",null,null],[0,"regex","","",null,null],[4,"Regex","regex_dfa::regex","A regular expression over the alphabet `T`.",null,null],[13,"Null","","The null set. This never matches anything.",0,null],[13,"Empty","","The empty string (matches exactly \"\").",0,null],[13,"Except","","Matches any single character except the listed ones.",0,null],[13,"Alt","","Alternation (also known as disjunction). Matches any of the contained\ncharacters, as well as any string matched by a contained regex.",0,null],[13,"And","","Conjunction. Matches iff all contained regexes match.",0,null],[13,"Not","","Negation. Matches iff the contained regex does not match.",0,null],[13,"Cat","","Concatenation. Matches iff the contained regexes match in sequence.",0,null],[13,"Kleene","","Kleene closure. Matches zero or more repetitions of the contained regex.",0,null],[4,"ParseError","","",null,null],[13,"UnexpectedEof","","",1,null],[13,"UnexpectedChar","","",1,null],[13,"BadRange","","",1,null],[11,"clone","","",0,{"inputs":[{"name":"regex"}],"output":{"name":"regex"}}],[11,"fmt","","",0,{"inputs":[{"name":"regex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"regex"},{"name":"regex"}],"output":{"name":"bool"}}],[11,"normalize","","",0,{"inputs":[{"name":"regex"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"parseerror"}],"output":{"name":"parseerror"}}],[11,"fmt","","",1,{"inputs":[{"name":"parseerror"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Err","","",null,null],[11,"from_str","","Parse a string as a regular expression.",0,{"inputs":[{"name":"regex"},{"name":"str"}],"output":{"name":"result"}}],[11,"nullable","","Tests whether a regular expression is nullable, i.e. whether it matches\nthe empty string.",0,{"inputs":[{"name":"regex"}],"output":{"name":"bool"}}],[0,"derivatives","regex_dfa","",null,null],[3,"Derivatives","regex_dfa::derivatives","The set of some object's derivatives with respect to an alphabet `T`.",null,null],[12,"d","","Holds a set of pairs `(chars, derivative)`, meaning that the derivative\nwith respect to any element of `chars` is `derivative`.",2,null],[12,"rest","","The derivative with respect to any character not listed in `d`.",2,null],[8,"Differentiable","","A trait for types which can be differentiated with respect to an alphabet\n`T`.",null,null],[10,"derivative","","",3,{"inputs":[{"name":"differentiable"}],"output":{"name":"derivatives"}}],[11,"clone","","",2,{"inputs":[{"name":"derivatives"}],"output":{"name":"derivatives"}}],[11,"fmt","","",2,{"inputs":[{"name":"derivatives"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"map","","",2,{"inputs":[{"name":"derivatives"},{"name":"f"}],"output":{"name":"derivatives"}}],[11,"derivative","regex_dfa::regex","",0,{"inputs":[{"name":"regex"}],"output":{"name":"derivatives"}}],[11,"derivative","collections::vec","",4,{"inputs":[{"name":"vec"}],"output":{"name":"derivatives"}}],[0,"dfa","regex_dfa","",null,null],[3,"State","regex_dfa::dfa","A state in a DFA.",null,null],[12,"by_char","","Labelled transitions.",5,null],[12,"default","","The default transition (for values not in `by_char`).\nNote that `by_char` is assumed not to cover the entire alphabet (`T`).",5,null],[12,"value","","A value associated with the state.",5,null],[3,"Dfa","","A deterministic finite automaton (DFA), over the alphabet `T`.\nEach state is annotated with a value of type `V`.\nState 0 is the starting state.",null,null],[12,"states","","The list of states.",6,null],[8,"Normalize","","",null,null],[10,"normalize","","",7,{"inputs":[{"name":"normalize"}],"output":{"name":"self"}}],[11,"clone","","",5,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"fmt","","",5,{"inputs":[{"name":"state"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"dfa"}],"output":{"name":"dfa"}}],[11,"fmt","","",6,{"inputs":[{"name":"dfa"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"normalize","collections::vec","",4,{"inputs":[{"name":"vec"}],"output":{"name":"self"}}],[11,"from_derivatives","regex_dfa::dfa","Construct a DFA from a list of differentiable objects.\nThe elements of `initial` form the first states of the DFA.\nReturns the DFA, together with a mapping from derivatives to state numbers.",6,null],[11,"map","","Apply a function to each state's value.",6,{"inputs":[{"name":"dfa"},{"name":"f"}],"output":{"name":"dfa"}}],[11,"reverse","","Find the reverse transitions from each state in the DFA.",6,{"inputs":[{"name":"dfa"}],"output":{"name":"vec"}}],[11,"minimize","","Minimize a DFA; i.e. find a DFA with the fewest states that is\nequivalent to the given DFA.\nTwo DFAs are equivalent if, given the same string, they always lead to a\nstate with the same associated value.",6,{"inputs":[{"name":"dfa"}],"output":{"name":"dfa"}}],[11,"eq","","",6,{"inputs":[{"name":"dfa"},{"name":"dfa"}],"output":{"name":"bool"}}],[11,"equiv","","Compare DFAs by language equality.",6,{"inputs":[{"name":"dfa"},{"name":"dfa"}],"output":{"name":"bool"}}]],"paths":[[4,"Regex"],[4,"ParseError"],[3,"Derivatives"],[8,"Differentiable"],[3,"Vec"],[3,"State"],[3,"Dfa"],[8,"Normalize"]]};
initSearch(searchIndex);
